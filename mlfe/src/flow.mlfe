module flow

export main/1

type action = Start | Stop | Fail | Help

import_type file.result

let main args =
  let path = flow_path() in
  match (parse_action args) with
    Start -> start path
  | Stop -> stop path
  | Fail -> fail path
  | _ -> help ()

let parse_action []        = Start
let parse_action ["start"] = Start
let parse_action ["d"]     = Stop
let parse_action ["done"]  = Stop
let parse_action ["f"]     = Fail
let parse_action ["fail"]  = Fail
let parse_action _         = Help

let fail path =
  match file.delete path with
    (Ok ())         -> :ok
  | (Error :enoent) -> :ok
  | (Error _)       -> :error

let start path =
  match file.read_file path with
    (Error :enoent) -> do_start path
  | (Ok _)          -> puts "Flow already started.~n" []

let do_start path =
  let time = format_time (universal_time ()) in
  match file.write_file path [time] with
    (Ok _)    -> :ok
  | (Error _) -> puts "Failed to write flow file~n" []

let stop path =
  match file.read_file path with
    (Error :enoent) -> puts "There is no running flow.~n" []
  | (Ok content)    ->
    let format =  c"~d-~d-~dT~d:~d:~d+0000" in
    let at = str.to_cstring content in
    beam :io_lib :fread [format, at] with
      (:ok, [y,m,d,h,min,s], []) ->
        let start_time = ((y,m,d),(h,min,s)) in
        let end_time = universal_time () in
        let duration = (to_seconds end_time) - (to_seconds start_time) in
        let write_res = write_ledger start_time end_time duration in
        let remove_res = fail path in
        puts "Flow lasted for ~w seconds.~n" [duration]
    | _ -> puts "Corrupted flow file.~n" []

let write_ledger start_time end_time duration =
  let path = ledger_path () in
  let old_ledger = read_ledger path in
  let output = [old_ledger,
                (format_time start_time), ",",
                (format_time end_time), ",",
                (str.from_int duration)] in
  match file.write_file path output with
    Ok ()   -> :ok
  | Error _ -> puts "Failed to write flow file~n" []

let read_ledger path =
  match file.read_file path with
    (Error :enoent) -> ""
  | (Ok old_ledger) -> concat_strings [old_ledger, "\n"]

let to_seconds datetime =
  beam :calendar :datetime_to_gregorian_seconds [datetime] with
    i, is_integer i -> i

let format_time ((year,month,day), (hour,minute,second)) =
  format_string (iso_format ())
                [year, month, day, hour, minute, second]

let universal_time () =
  beam :calendar :universal_time [] with (d,t) -> (d,t)

let iso_format () = "~w-~2.2.0w-~2.2.0wT~2.2.0w:~2.2.0w:~2.2.0w+0000"

let format_string format args =
  beam :io_lib :format [format, args] with
    iolist -> str.from_iolist iolist

let flow_path () =
  let root = get_env_or_default "HOME" "/tmp" in
  concat_strings [root,  "/", ".flow"]

let ledger_path () =
  let root = get_env_or_default "HOME" "/tmp" in
  concat_strings [root,  "/", "flow_ledger.csv"]

let concat_strings strings = str.from_iolist strings

let get_env_or_default var default =
  beam :os :getenv [var] with
    false                 -> default
  | value, is_chars value -> str.from_cstring value

let help () =
  let w = puts "Usage:~n" [] in
  let x = puts "flow [start] - start a new flow~n" [] in
  let y = puts "flow d[one] - record a succesful flow~n" [] in
  let z = puts "flow f[ail] - fail the current flow~n" [] in :ok

let puts format args =
  beam :io :format [format, args] with :ok -> :ok
